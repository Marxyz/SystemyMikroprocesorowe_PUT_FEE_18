C51 COMPILER V9.59.0.0   MAIN                                                              12/06/2018 01:21:53 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "aduc831.h"  /* Definitions of ADuC831 registers name */
   2          #include "stdint.h"   /* Standard integers */
   3          #include "stdfloat.h"  /* Standard float */
   4          #include "IO.h"       /* Input/output definitions */
   5          #include <stdlib.h> /* for atof() */
   6          #include <string.h> /* for memset() and memcpy() */
   7          
   8          #define ca_Vref 5.0
   9          #define ca_Resolution 12
  10          #define ca_Maximum_Value ((0x000001ul<<ca_Resolution)-1)
  11          #define F_OSC 11058000
  12          #define pars 12
  13          #define t_resol 16
  14          #define OKRES 1
  15          
  16          #define Tx_Tau(dzielnik) (float)((float)dzielnik/F_OSC)
  17          #define Tx_N(czas_ms, dzielnik) (unsigned int)((float)czas_ms/Tx_Tau(dzielnik)/1000.0)
  18          #define T1_Rejestr(czas_ms) ((0x000001ul<<t_resol)-Tx_N(czas_ms,pars))
  19          #define T1_Set(czas_ms) TL1 = T1_Rejestr(czas_ms);TH1 = T1_Rejestr(czas_ms)>>8;
  20          
  21          #define RAMKA_TYP (0)
  22          #define RAMKA_OKRES (2)
  23          #define RAMKA_AMPLITUDA (6)
  24          #define RAMKA_OFFSET (10)
  25          #define RAMKA_ROSNACE (14)
  26          #define RAMKA_OPADAJACE (18)
  27          
  28          /*! 
  29          @var char terminal[30] 
  30          @brief Input from user.  
  31          */
  32          xdata char terminal[30];
  33          
  34          /*! 
  35          @var int itr 
  36          @brief Iterator used in UART Interrupt.  
  37          */
  38          xdata int itr = 0;
  39          
  40          /*! 
  41          @var int ready 
  42          @brief Flag setted by UART Interrupt when input from user was read. 
  43          */
  44          xdata int ready = 0;
  45          
  46          /*! 
  47          @var char type 
  48          @brief Represents currently emitted signal. 
  49           * p - pila
  50           * t - prostokat
  51          */
  52          xdata char type = 'p';
  53          
  54          
C51 COMPILER V9.59.0.0   MAIN                                                              12/06/2018 01:21:53 PAGE 2   

  55          /**
  56           * @brief UART interrupt to fill terminal.
  57           *
  58           * line of data specified as:
  59           * char type of plot, float amplitude, float offset
  60           * float rosnace, float opadajace. Formatted without ',' delimiter
  61           */
  62          void uartInterrupt () interrupt 4
  63          {
  64   1        char buffer;
  65   1        if(RI)
  66   1        {
  67   2          buffer = _getKey();
  68   2          if((buffer == '\r'))
  69   2          { 
  70   3            terminal[itr] = '\0';     
  71   3            itr = 0;
  72   3            ready = 1;
  73   3          }
  74   2          else
  75   2          {
  76   3            terminal[itr] = buffer;
  77   3            SBUF = terminal[itr];
  78   3            itr++;
  79   3          }
  80   2          RI=0;
  81   2        }
  82   1        if(TI){
  83   2          TI = 0;
  84   2        }
  85   1        return;
  86   1      }
  87          
  88          /**
  89           * @brief Floating point modulo operation. Takes two float32_t numbers.
  90           * 
  91           * @param a The nominator float32_t number
  92           * @param b The denominator float32_t number
  93           * @return float32_t The result of operation.
  94           */
  95          float32_t modulo(float32_t a, float32_t b)
  96          {
  97   1        int16_t result = (int16_t)(a/b);
  98   1        return  a - (float32_t)(result ) *b;
  99   1      }
 100          
 101          
 102          /**
 103           * @brief Structure representing signal parameters.
 104           * Okres - singal period interval.
 105           * Amplituda - signal amplitude.
 106           * Offset - generating signal offset.
 107           * t - should not be set, accumulates time for inner calculation
 108           * delta_t - should not be set, calculated during initialization
 109           * rosnace - time of signal's rising slope
 110           * opadajace - time of signal's declining slope.
 111           */
 112          typedef struct
 113          {
 114            double okres; 
 115            double amplituda;
 116            double offset;
C51 COMPILER V9.59.0.0   MAIN                                                              12/06/2018 01:21:53 PAGE 3   

 117            double t;
 118            double delta_t;
 119            double rosnace;
 120            double opadajace;
 121          }parametry_sygnalu_t;
 122          
 123          
 124          /**
 125           * @brief Generates single signal sample.
 126           * 
 127           * @param parametry_sygnalu_t* syg Signal parameters pointer
 128           * @return float32_t Calculated sample.
 129           */
 130          float32_t GenerateTrojkat(parametry_sygnalu_t* syg)
 131          {
 132   1        // Setting values of signal in fixed declaration outside of given reference, in order to save CODE memory
             -.
 133   1        float32_t time, result;
 134   1        double A = syg->amplituda;
 135   1        double T = syg->okres;
 136   1        double off = syg->offset;
 137   1        double ros = syg->rosnace;
 138   1        double opad = syg->opadajace;
 139   1        double del = syg->delta_t;
 140   1        time = modulo(syg->t,T);
 141   1        if(time > ros )
 142   1        {
 143   2          result = -A  * 1.0 / (opad) *(time - ros) + A + off;
 144   2              return result;
 145   2        }
 146   1        else
 147   1        {
 148   2          result =   A*time/(ros) + off;
 149   2        }
 150   1          
 151   1        
 152   1          return result;
 153   1      }
 154          
 155          /**
 156           * @brief Generates single signal sample.
 157           * 
 158           * @param parametry_sygnalu_t* syg Signal parameters pointer
 159           * @return float32_t Calculated sample.
 160           */
 161          
 162          float32_t pila(parametry_sygnalu_t* syg)
 163          {
 164   1        return syg->amplituda*(modulo(syg->t, (syg->okres)))/(syg->okres) + syg->offset;
 165   1      }
 166          
 167          /**
 168           * @brief Union representing sample value in register memory.
 169           * 
 170           */
 171          typedef union
 172          {
 173            uint16_t wartosc;
 174            struct
 175            {
 176              uint8_t bajt_gorny;
 177              uint8_t bajt_dolny;
C51 COMPILER V9.59.0.0   MAIN                                                              12/06/2018 01:21:53 PAGE 4   

 178            }slowo;
 179          }probka_t;
 180          
 181          xdata probka_t probka = {0};
 182          xdata float32_t probka_napiecie = 0;
 183          xdata parametry_sygnalu_t sygnalParam;
 184          
 185          
 186          
 187          /**
 188           * @brief Timer interrupt function.
 189           * Generates signal samples and instructs analog outputs to emit signal.
 190           *
 191           * 
 192           */
 193          void timer1() interrupt 3
 194          {
 195   1        T1_Set(OKRES);
 196   1        sygnalParam.t += sygnalParam.delta_t;
 197   1        if(sygnalParam.t > sygnalParam.okres)sygnalParam.t = sygnalParam.delta_t;
 198   1        switch (type){
 199   2          case 'p':
 200   2          {
 201   3            probka_napiecie = pila(&sygnalParam);
 202   3            probka_napiecie = (probka_napiecie>ca_Vref)? ca_Vref : probka_napiecie;
 203   3            probka_napiecie = (probka_napiecie < 0)? 0: probka_napiecie;
 204   3            probka.wartosc = (uint16_t)(probka_napiecie/ca_Vref * (float32_t)ca_Maximum_Value);
 205   3            break;
 206   3          }
 207   2          case 't':
 208   2          {
 209   3            probka_napiecie = GenerateTrojkat(&sygnalParam);
 210   3            probka_napiecie = (probka_napiecie>ca_Vref)? ca_Vref : probka_napiecie;
 211   3            probka.wartosc = (uint16_t)(probka_napiecie* (1.0 / (1.0 * ca_Vref ))* (float32_t)ca_Maximum_Value);
 212   3            break;
 213   3          }
 214   2        }
 215   1        //probka_napiecie = GenerateTrojkat(&sygnalParam);
 216   1        
 217   1        DAC0H = probka.slowo.bajt_gorny;
 218   1        DAC0L = probka.slowo.bajt_dolny;
 219   1      }
 220          
 221          /**
 222           * @brief Getting parameters from input and setting them to global sygnalParam structure.
 223           * 
 224           * @bug using sscanf - probably undefined behaviour, cannot read more than 5 floats, but return value from
             - sscanf is correct.
 225           * @return void
 226           */
 227          
 228          void getParameters()
 229          {
 230   1        xdata float tmp;
 231   1        xdata char string[4];
 232   1        if(ready == 1)
 233   1          {
 234   2            TR1=0;
 235   2            //sscanf(terminal, "%cO%fA%fF%fR%fP%g" , &type, &sygnalParam.okres, &sygnalParam.amplituda, &sygnalPara
             -m.offset, &sygnalParam.rosnace, &sygnalParam.opadajace);
 236   2            //tmp = (float)(atoi(&terminal[2])) + (float)(atoi(&terminal[4]))/10 ;
 237   2            //sygnalParam.okres = tmp;
C51 COMPILER V9.59.0.0   MAIN                                                              12/06/2018 01:21:53 PAGE 5   

 238   2            type = terminal[RAMKA_TYP];
 239   2            
 240   2            memcpy(string, &terminal[RAMKA_OKRES],3);
 241   2            string[3] = '\0';
 242   2            sygnalParam.okres = atof(string);
 243   2            memset(string,0,4);
 244   2            
 245   2            memcpy(string, &terminal[RAMKA_AMPLITUDA],3);
 246   2            string[3] = '\0';
 247   2            sygnalParam.amplituda = atof(string);
 248   2            memset(string,0,4);
 249   2            
 250   2            memcpy(string, &terminal[RAMKA_OFFSET],3);
 251   2            string[3] = '\0';
 252   2            sygnalParam.offset = atof(string);
 253   2            memset(string,0,4);
 254   2            
 255   2            memcpy(string, &terminal[RAMKA_ROSNACE],3);
 256   2            string[3] = '\0';
 257   2            sygnalParam.rosnace = atof(string);
 258   2            memset(string,0,4);
 259   2            
 260   2            memcpy(string, &terminal[RAMKA_OPADAJACE],3);
 261   2            string[3] = '\0';
 262   2            sygnalParam.opadajace = atof(string);
 263   2            memset(string,0,4);
 264   2            
 265   2            memset(terminal, 0, sizeof(terminal[0])*30);
 266   2            ready = 0;
 267   2            TR1 = 1;
 268   2          }
 269   1      }
*** WARNING C280 IN LINE 230 OF main.c: 'tmp': unreferenced local variable
 270          
 271          /**
 272           * @brief Program entry point.
 273           * 
 274           * @return int
 275           */
 276          
 277          int main()
 278          {
 279   1        ET1 = 1;
 280   1        EA = 1;
 281   1        // UART INTERRUPT
 282   1        ES = 1;
 283   1        DACCON = 0x7F;
 284   1        TMOD = 0x10;
 285   1        
 286   1        
 287   1        REN = 1;
 288   1        SM0 = 0x00;
 289   1        SM1 = 0x01;
 290   1        
 291   1        //TIMER3 SETTINGS
 292   1        T3CON = 0x81;
 293   1        T3FD = 0x20;
 294   1        
 295   1        //INTERRUPT PRIORITY
 296   1        PS=1;
 297   1        PT1=0;
 298   1        
C51 COMPILER V9.59.0.0   MAIN                                                              12/06/2018 01:21:53 PAGE 6   

 299   1        //DEFAULTS
 300   1        sygnalParam.okres = 3.0;
 301   1        sygnalParam.amplituda = 3.0;
 302   1        sygnalParam.offset = 1;
 303   1        sygnalParam.t = 0.0;
 304   1        sygnalParam.rosnace = 1.5;
 305   1        sygnalParam.opadajace = 1.5;
 306   1        sygnalParam.delta_t = ((float32_t)OKRES/1000.0);
 307   1        
 308   1        T1_Set(OKRES)
 309   1        TR1 = 1;
 310   1        while(1)
 311   1        {
 312   2          getParameters();
 313   2        };
 314   1        
 315   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1427    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     69       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      43
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
